# THEME 4 - CondomiX - Part 1

Condominium Management

[Documentation (generated by Doxygen)](http://project-aeda-p1-g4-t3-1920.epizy.com/)



## Getting started

Starting the program you will be asked if you rather create a new condominium or retrieve the information stored in text files.

- If you choose to create a new condominium you will be asked how many cleaning providers are allowed to provide cleaning services to the condominium, this is a fixed number;
- If you choose to read from files the formats of those same files are:

1. [condominium_example.txt (portuguese)](https://github.com/skdGT/ProjetoAEDA/blob/master/parte1/condominio_format.txt)

```
num_prestadores_limpeza
condominos_filename
num_hab
ID hab0
ocupado ? (1 - sim / 0 - nao)
morada
area_hab
tipologia / area_ext
piso / piscina (1 - sim / 0 - nao)
mensalidade
::::::::::
ID hab1
ocupado ? (1 - sim / 0 - nao)
morada
area_hab
tipologia / area_ext
piso / piscina (1 - sim / 0 - nao)
mensalidade
... (and so on)
```

2. [members_example.txt (portuguese)](https://github.com/skdGT/ProjetoAEDA/blob/master/parte1/condominos_format.txt)

```
num_condominos
nome_cond0
nif
num_hab
id_hab0
id_hab1
num_servicos
serv0 : custo : prestador
serv1 : custo : prestador
::::::::::
nome_cond1
nif
num_hab
id_hab0
id_hab1
num_servicos
serv0 : custo : prestador
serv1 : custo : prestador
```

â€‹	When the reading operation is concluded the display will show how much time that operation took.



## Main functionalities

On this program you can:

- View Members
  - Add Members
  - Remove Members
  - Sort Members
  - Request a Service for a Member
- View Habitations
  - Add Habitations
  - Remove Habitations
  - Assign Habitations
  - Unassign Habitations
  - Sort Habitations
  - View all Apartments
  - View all Villas
- View Services provided
- View Income



### Members

- `Members` have a `name`, a unique `nif`, a `vector` of `Habitations`, a `vector` of `Services `and a `monthly_payment`;
- A `Member `can have multiple habitations, and request an undetermined number of services. These factors will, ultimately, modify the `monthly payment`;
- Members can be sorted by name or monthly payment, ascending or descending.



### Habitations

- `Habitations` can either be apartments or villas;

- `Habitations` have an unique ID:

  - starting with `A0` for apartments;
  - starting with `V0` for villas;

- `Habitations` have an address:

  - **MUST** be given as:

    `<Street>, <Location>, <Number>, <Zip-Code>`

- `Habitations` have a `monthly_payment`, an `habitational_area` and `status` (true - occupied);

- `Apartments` have a `floor `and a `typology`;

- `Villas`have a `external_area` and can have a `pool`;

- `Habitations` can be sorted by `monthly_payment` or `habitational_area`, ascending or descending;



### Assigning and Unassigning Habitations

- As logic says, can only assign unoccupied habitations to a member, and can't unassign habitations that are not yet assigned.



### Removing Habitations

- When trying to remove habitations, make sure the habitation is not assigned or it will raise an exception saying the habitation cannot be removed as it is occupied.



## Some algorithms

### 1. Finding an habitation, member or service:

- As we only work with pointers, finding something is relatively easy and very low-time consuming.

Here's an example:

```c++
template<class T>
T *Condominio::findX(parameter_to_find) {
    if (this->getVector() == 0)
        throw NoSuchObject(parameter_to_find);
    for (int i = 0; i < this->getVector(); i++)
    {
        if (this->getVector()[i]->getParameterToFind() == paramenter_to_find)
            return this->getVector()[i];
    }
    throw NoSuchObject(parameter_to_find);
}
```



### 2. Sorting Members and Habitations:

- Unless we are using a massive number of objects, i.e. Habitations and Members, we think that the Bubble Sort algorithm was a good idea.

```c++
template <class Comparable>
void bubbleSort(vector<Comparable> &v) {
	for (unsigned int j = v.size() - 1; j > 0; j--) {
	bool troca=false;
	for (unsigned int i = 0; i < j; i++)
		if (v[i+1] < v[i]) {
			swap(v[i], v[i+1]);
			troca = true;
		}
	if (!troca) return;
	}
}
```



### 3. Parsing a string

- We used an algorithm to parse a string giving a delimiter;
- For example:
  - When we ask for the address in a specific format, it's because we parse the address with  `', '` as delimiter.

```c++
vector<string> split (string &s, string delimiter) {
    size_t pos = 0;
    std::string token;
    vector<string> result;
    while ((pos = s.find(delimiter)) != std::string::npos) {
        token = s.substr(0, pos);
        result.push_back(token);
        s.erase(0, pos + delimiter.length());
    }
    result.push_back(s);
    return result;
}
```



## Exiting the program

The user will be asked if they want to save the data in a text file or discard it, or even cancel the exiting operation going back to where the program was before issuing the exit command.

If the user opts to save the information will be asked for the filenames that they wish to store the information in. Then the program will call a function to write the data to files, showing how much time it took.



## External Libraries

- We used [libfort]( https://github.com/seleznevae/libfort ) library on our project, so big thanks to seleznevae for his work on creating a library that allowed us to easily create formated tables for our data.





  
